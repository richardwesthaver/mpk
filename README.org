#+TITLE: mpk
#+DATE: 2022-03-16
#+AUTHOR: ellis
#+EMAIL: ellis@rwest.io
#+DESCRIPTION: Media Production Kit

=mpk= is my /Media Programming Kit/ -- a development kit for digital
media, taking lessons learned from the software industry and applying
them to creative pursuits. It is a flexible ecosystem designed to
organize my workflow involving hardware, software, and data. Batteries
are *not* included.

* Status
This project is quite young and will only deal with audio for quite
some time since that's the medium I'm most interested in. There are
future plans for image/video support followed by VR/AR. The core APIs
are written in Rust but there are bindings for C and Python (see
[[*=mpk_ffi=][mpk_ffi]]).

Right now my focus is on the SQLite[fn:5] database and cataloging
libraries of audio tracks and samples. The database is designed to
capture as much information as possible with minimal user
configuration and input. The libraries have a fairly flat directory
structure -- a far cry from most music library programs which
encourage a deeply nested structure (=Tracks -> Artist -> Album ->
track.wav=).

Once I'm happy with the database I'll work on the MIDI module
([[*=mpk_midi=][mpk_midi]]), add playback/record/transcode capabilities
([[*=mpk_audio=][mpk_audio]]/[[*=mpk_codec=][mpk_codec]]), and then get started on session management
functionality ([[*=mpk_sesh=][mpk_sesh]]).

mpk_audio also includes a metronome and sample chainer[fn:6] which I
plan to tweak over the next few weeks since they have well-defined
requirements.

* Modules
** =mpk=
The MPK binary providing CLI access to the library features.
** =mpk_config=
User configuration with read/write support for TOML (typically from
=mpk.toml=). Used to initialize other modules at runtime (for example
=DbConfig= for =Mdb::new_with_config=).
** =mpk_db=
The =Mdb= struct provides an API to the underlying SQLite database
which works with the custom structs defined in =src/types.rs=. 
** =mpk_py=
The MIR[fn:1] tool (=mpk_extract.py=) uses Python as a bridge
between Essentia[fn:2] for feature extraction and the MPK
database. There are a huge amount of features stored in the database
(/97/ at time of writing), but the feature set will be reduced in
future iterations as I find the features which are most useful to
me. As for the extraction algorithms, My plan is to RiiR[fn:3] and
reduce DB size by applying zstd[fn:4] compression.

#+begin_src artist
           +------------------+                             
           |  mpk_extract.py  |                            _____________        
           +--------+---------+                           /             \       +--------+  +-----------------+
                    |                                 +-}| Extract(f[0]) |----->| POOL[0]|  |       DB        |
                    |                                /    \____________ /       |  -  -  |  | -  -  -  -  -  -|
                    |              +---------+      /      _____________    |   | POOL[1]|  |        |        |
            +---------------+      |         |     /      /             \       |  -  -  |  |                 |
            |collect_files()|{---->| [files] |----X-----}| Extract(f[1]) |----->|        |  | tracks | samples|
            +---------------+      |         |     \      \____________ /       |[ .... ]|  |                 |
                 /    \            +---------+      \      _____________    |   |        |  |        |        |
                /      \                             \    /             \       |  -  -  |  |                 |
               /        \                             +-}| Extract(f[N]) |----->| POOL[N]|  |        |        |
              o          o                                \____________ /       +--------+  +-----------------+
  +-----------------+-----------------+                                             |         ^
  |                 |                 |                                             v         |
  |     tracks      |     samples     |                                       +------------+  |
  |                 |                 |                                       | insert_*() |--+
  +-----------------+-----------------+                                       +------------+  

#+end_src

** =mpk_ffi=
C-compatible MPK FFI with C-header and python binding generators.
** =mpk_audio=
The audio module leverages [[https://github.com/RustAudio/cpal][cpal]] and [[https://github.com/RustAudio/rodio][rodio]] for audio playback and
recording. It provides high-level standalone tools with simple use
cases such as playing an audio file on disk and isn't designed for
low-level DSP.
** =mpk_flate=
Zstd compression and Tar archival utilities.
** TODO =mpk_codec=
Audio file encoding and decoding.
** TODO =mpk_gear=
MPK interface for hardware devices connected via USB.
- Elektron Octatrack MKII
- Elektron Analog Rytm MKII
- DSI Prophet Rev2
- Korg SV-1
** TODO =mpk_jack=
MPK interface for JACK.
** TODO =mpk_sesh=
MPK session management. Inspired by NSM[fn:7].
** TODO =mpk_midi=
MPK MIDI interface supporting real-time processing, encoding/decoding,
and Sysex patching.
* Footnotes
[fn:1]  [[https://en.wikipedia.org/wiki/Music_information_retrieval][Music information retrieval - Wikipedia]]

[fn:2] [[https://essentia.upf.edu/][Essentia - Music Technology Group - Universitat Pompeu Fabra]] 

[fn:3] [[https://transitiontech.ca/random/RIIR][ansuz - /random/RIIR]]

[fn:4] [[http://facebook.github.io/zstd/][Zstandard - Real-time data compression algorithm]] 

[fn:5] [[https://www.sqlite.org/index.html][SQLite Home Page]] 

[fn:6] [[https://github.com/KaiDrange/OctaChainer][GitHub - KaiDrange/OctaChainer]] 

[fn:7] [[http://non.tuxfamily.org/wiki/Non%20Session%20Manager][Non Session Manager]]

* Dependencies
- [[https://www.rust-lang.org/tools/install][Rust]] :: use =cargo= to install =mpk=
- Python3 :: use =pip= to install =mpk_extract= and =mpk= python package.
  - your mileage may vary on Py3.10. If installation fails try it on 3.9.
- _Dev Dependencies_
  - essentia :: try a =pip install= from the [[https://github.com/MTG/essentia][github repo]], if that
    doesn't work you will need to [[https://essentia.upf.edu/installing.html][install from source]]. If you have
    issues just contact me.
  - numpy :: you will need a version <1.22, for example =pip install numpy==1.21.5=.
  - poetry :: =pip= or OS package manager
  - black :: =pip= or OS package manager
  - Nim :: OS package manager
    - used as a build tool via [[https://nim-lang.org/docs/nims.html][NimScript]].
  - C Compiler :: GCC or LLVM
    - Valgrind :: OS package manager
      - used to detect issues with FFI memory management.
  - SQLite :: OS package manager
    - required by =mpk_db=
  - JACK :: OS package manager
    - required by =mpk_jack=

* COMMENT notes
** tasks
*** TODO finish mpk_extract [4/6]
**** DONE debug CStrings                                                :ffi:
some strings fields are broken when inserting to db - UUIDs, VecText, and VecReal
- test DB blob insert with floats. if these are ok then they can be ignored
- check CStrings and make sure they're handled correctly
**** DONE upserts                                                        :db:
add update functionality with =WHERE= clauses
**** DONE retrieve sample_id correctly
should never insert id of 0 when duplicate found, update or noop instead
**** DONE account for missing values in essentia
essentia will miss fields if sample is too short
**** TODO get paths from config                                   :config:
input else tracks/samples from config else current path
**** TODO incremental batch extractor
- this will likely require a threadpool
- extractor segfaults when working with large directories, need to
  insert into db after each extraction
**** TODO populate all columns in tracks table
Currently only inserting path
*** TODO mpk_config updates [1/3]
**** DONE add support for external paths
add external track/sample locations
**** TODO add support for Elektron USB mode                         :gear:
add external drive locations

**** TODO env variables
- =MPK_CONFIG=
- =MPK_SAMPLES=
- =MPK_TRACKS=
- =MPK_LOG= ?

- use enum?
- macros only return value at compile-time. need to use std::env functions directly
**** TODO metro and chain config
- both subsections in audio section - [audio.chain] and [audio.metro]?
  - audio.chain default output
  - audio.metro default bpm/sig tic/toc
*** TODO mpk_midi init [0/1]
just need enough to make emacs integration - =mpk-midi.el=
can start with terminal process then move to C dynamic module
check [[https://github.com/jnykopp/emaccordion][jnykopp/emaccordion]]
**** TODO MIDI config                                                :config:

** notes
*** Background
Over the years I've seen many popular creative tools implement
subscription-based/freemium payment models, web-based/always-online
tech, non-features/bloat, incompatible APIs, and colorful marketing. I
don't care for any of these things and I don't like the direction
these tools are taking us. The philosophy always seems to be that the
computer impedes our ability to be creative -- but don't worry, this
product will hide all the tricky bits from you so that you can focus
on what matters - making things!

In reality such tools do indeed hide the tricky bits. You can launch
these applications with a pretty GUI, plug in your hardware and
start working immediately. No need to pop the hood and look inside,
because things Just Work. This is quite valuable, especially for the
average user who doesn't want to dive head first into the endless pit
that is modern-day multimedia programming and configuration. There are
some significant drawbacks to this methodology though.

First, when you run into unexpected behavior such as your Audio
Interface not being recognized by your tools, you need to pray that
someone more knowledgeable than you has encountered the same issue and
that there is a fix available that is compatible with your tools. In
the worst case you might not even know how to describe your issue and
spend a night or two furiously googling for answers. In most cases you
can probably find a solution, but you don't actually learn anything
meaningful from this experience. You're just putting a bandaid on and
not reasoning about why you're bleeding in the first place.

Another thing I've noticed with these types of tools is that we become
very committed to them. This is not specific to creative tools, and
the best example that comes to mind is Emacs vs Vim which are two code
editors that serve virtually the same purpose as far in as they edit
text. The two communites, separated by a line in the sand are very
committed to their tool of choice, and the friendly competition
between them helps drive feature development for both
projects. However, this type of commitment can be /dangerous/ for
purely creative pursuits. In today's digital world, the tools we
choose define the work we are capable of more than ever before. If we
commit to a specific creative tool and decide that this is how we will
use the computer to create things, we will only ever be capable of
what our tools can do. Never commit.

My final objection to modern creative tools has to do with those
tricky bits I previously mentioned. That's where the magic is. 
*** lilypond
#+begin_src lilypond :file /tmp/lp1.png
  \relative c' {
    g a b c
    d e f g
    f e d c
    b a g a
    b c d e
    f g f e
    d c b a
    g1
  }
#+end_src

*** thoughts
- studio management, organization, support, storage, indexing
  - database
- mediums & medias
- Software
  - Patchers
    - [[https://cycling74.com/products/max][Max]]
    - [[https://puredata.info/][Pure Data]]
    - [[https://www.native-instruments.com/en/products/komplete/synths/reaktor-6/][Reaktor]]
  - DAWs
    - [[https://www.ableton.com][Ableton Live]]
    - [[https://www.bitwig.com/][Bitwig Studio]]
    - [[https://www.reasonstudios.com/][Reason]]
    - [[https://www.image-line.com/][FL Studio]]
- Hardware
  - [[https://www.elektron.se/products/octatrack-mkii/][Octatrack]]
  - [[https://teenage.engineering/products/op-z][OP-Z]]
  - [[https://buchla.com/][Buchla]]
- Music
  - [[https://www.youtube.com/watch?v=DWuAn6C8Mfc][Radiohead]]
  - [[https://www.youtube.com/watch?v=PGwPSPIhohk][Pink Floyd]]
  - [[https://www.youtube.com/watch?v=6ZwItYjqXR0][FJAAK]]
  - [[https://www.youtube.com/watch?v=mjlOw6dNeS0][Bassnectar]]
  - [[https://www.youtube.com/watch?v=3cSqRMioRik][Partibio69]]
  - [[https://www.youtube.com/watch?v=J8sS5NkADBE][VURRO]]
  - [[https://www.youtube.com/watch?v=PoJKpE165_w][Ajax Spearman of the Sun]]
  - [[https://www.youtube.com/watch?v=tbLt0S0W5jE][Venetian Snares]]
  - [[https://www.youtube.com/watch?v=961uG4Ixg_Y][Aphex Twin]]
  - [[https://www.youtube.com/watch?v=6ZwItYjqXR0&list=RDMM][Meng Qi]]
  - [[https://disasterpeace.com][Disasterpeace]]
*** tech
- notation
- patchers
- plugins
- data
- ui
- net
- tracker??
- io
*** sql notes
Indexes should not be used in −
- Small tables.
- Tables that have frequent, large batch update or insert operations.
- Columns that contain a high number of NULL values.
- Columns that are frequently manipulated.

#+begin_src sql
attach database 'db' as 'alias'

detach database 'alias'

.tables
.schema 

create table db.table_name(
  id int primary key not null,
  name text not null,
  rms real
)

drop table db.table_name

insert into table_name ([c1,c2,c3]) values (v1,v2,v3)

select c1,c2,c3 from table_name

select * from table_name

select tbl_name from sqlite_master where type = 'table'

select c1,c2,c3 from table_name where c1 > c2

select count(*) as 'count' from table

select current_timestamp

select c1 from table where exists (select c1 from table where c3 > 65)

update table set c1 = 'val' where c1 = 'noval'

delete from table where COND

select distinct c3 from table limit 3 offset 2 group by c1 having count(c1) > 2 order by c2 asc

pragma pragma_name
pragma pname = 2

select name from sqlite_master where type = 'trigger'

drop trigger 'trigger_name'
#+end_src

- UUID conversion
  #+begin_src sql
select hex (artistid) from track_tags_musicbrainz

SELECT substr(hex(artistid), 1, 8)
|| '-' || substr(hex(artistid), 9, 4)
|| '-' || substr(hex(artistid), 13, 4)
|| '-' || substr(hex(artistid), 17, 4)
|| '-' || substr(hex(artistid), 21, 12)
FROM [track_tags_musicbrainz]
  #+end_src


** local_vars
#+begin_comment
Local variables:
mode: org
end:
#+end_comment
